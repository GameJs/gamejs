// Generated by CoffeeScript 1.4.0
(function() {
  var Mask, gamejs, objects;

  gamejs = require('../gamejs');

  objects = require('./utils/objects');

  /*
   * @fileoverview Image masks. Usefull for pixel perfect collision detection.
  */


  /*
   * Creates an image mask from the given Surface. The alpha of each pixel is checked
   * to see if it is greater than the given threshold. If it is greater then
   * that pixel is set as non-colliding.
   *
   * @param {gamejs.Surface} surface
   * @param {Number} threshold 0 to 255. defaults to: 255, fully transparent
  */


  exports.fromSurface = function(surface, threshold) {
    var alpha, dims, i, imgData, mask, x, y, _i, _ref;
    threshold = threshold && (255 - threshold) || 255;
    imgData = surface.getImageData().data;
    dims = surface.getSize();
    mask = new Mask(dims);
    for (i = _i = 0, _ref = imgData.length; _i <= _ref; i = _i += 4) {
      /* y: pixel # / width
      */

      y = parseInt((i / 4) / dims[0], 10);
      /* x: pixel # % width
      */

      x = parseInt((i / 4) % dims[0], 10);
      alpha = imgData[i + 3];
      if (alpha >= threshold) {
        mask.setAt(x, y);
      }
    }
    return mask;
  };

  /*
   * Image Mask
   * @param {Array} dimensions [width, height]
   *
  */


  Mask = exports.Mask = function(dims) {
    /* @ignore
    */

    var i, j, _i, _j, _ref, _ref1;
    this.width = dims[0];
    /* @ignore
    */

    this.height = dims[1];
    /* @ignore
    */

    this._bits = [];
    for (i = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      this._bits[i] = [];
      for (j = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        this._bits[i][j] = false;
      }
    }
  };

  /*
   * @param {gamejs.mask.Mask} otherMask
   * @param {Array} offset [x,y]
   * @returns the overlapping rectangle or null if there is no overlap
  */


  Mask.prototype.overlapRect = function(otherMask, offset) {
    var arect, brect, xEnd, xStart, yEnd, yStart;
    arect = this.rect;
    brect = otherMask.rect;
    if (offset) {
      brect.moveIp(offset);
    }
    /* bounding box intersect
    */

    if (!brect.collideRect(arect)) {
      return null;
    }
    xStart = Math.max(arect.left, brect.left);
    xEnd = Math.min(arect.right, brect.right);
    yStart = Math.max(arect.top, brect.top);
    yEnd = Math.min(arect.bottom, brect.bottom);
    return new gamejs.Rect([xStart, yStart], [xEnd - xStart, yEnd - yStart]);
  };

  /*
   *
   * @returns True if the otherMask overlaps with this map.
   * @param {Mask} otherMask
   * @param {Array} offset
  */


  Mask.prototype.overlap = function(otherMask, offset) {
    var arect, brect, count, overlapRect, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
    overlapRect = this.overlapRect(otherMask, offset);
    if (overlapRect === null) {
      return false;
    }
    arect = this.rect;
    brect = otherMask.rect;
    if (offset) {
      brect.moveIp(offset);
    }
    count = 0;
    for (y = _i = _ref = overlapRect.top, _ref1 = overlapRect.bottom; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
      for (x = _j = _ref2 = overlapRect.left, _ref3 = overlapRect.right; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
        if (this.getAt(x - arect.left, y - arect.top) && otherMask.getAt(x - brect.left, y - brect.top)) {
          return true;
        }
        /*
        NOTE this should not happen because either we bailed out
        long ago because the rects do not overlap or there is an
        overlap and we should not have gotten this far.
        throw new Error("Maks.overlap: overlap detected but could not create mask for it.")
        */

      }
    }
    return false;
  };

  /*
   * @param {gamejs.mask.Mask} otherMask
   * @param {Array} offset [x,y]
   * @returns the number of overlapping pixels
  */


  Mask.prototype.overlapArea = function(otherMask, offset) {
    var arect, brect, count, overlapRect, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
    overlapRect = this.overlapRect(otherMask, offset);
    if (overlapRect === null) {
      return 0;
    }
    arect = this.rect;
    brect = otherMask.rect;
    if (offset) {
      brect.moveIp(offset);
    }
    count = 0;
    for (y = _i = _ref = overlapRect.top, _ref1 = overlapRect.bottom; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
      for (x = _j = _ref2 = overlapRect.left, _ref3 = overlapRect.right; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
        if (this.getAt(x - arect.left, y - arect.top) && otherMask.getAt(x - brect.left, y - brect.top)) {
          count++;
        }
      }
    }
    return count;
  };

  /*
   * @param {gamejs.mask.Mask} otherMask
   * @param {Array} offset [x,y]
   * @returns a mask of the overlapping pixels
  */


  Mask.prototype.overlapMask = function(otherMask, offset) {
    var arect, brect, mask, overlapRect, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
    overlapRect = this.overlapRect(otherMask, offset);
    if (overlapRect === null) {
      return 0;
    }
    arect = this.rect;
    brect = otherMask.rect;
    if (offset) {
      brect.moveIp(offset);
    }
    mask = new Mask([overlapRect.width, overlapRect.height]);
    for (y = _i = _ref = overlapRect.top, _ref1 = overlapRect.bottom; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
      for (x = _j = _ref2 = overlapRect.left, _ref3 = overlapRect.right; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
        if (this.getAt(x - arect.left, y - arect.top) && otherMask.getAt(x - brect.left, y - brect.top)) {
          mask.setAt(x, y);
        }
      }
    }
    return mask;
  };

  /*
   * Set bit at position.
   * @param {Number} x
   * @param {Number} y
  */


  Mask.prototype.setAt = function(x, y) {
    return this._bits[x][y] = true;
  };

  /*
   * Get bit at position.
   *
   * @param {Number} x
   * @param {Number} y
  */


  Mask.prototype.getAt = function(x, y) {
    x = parseInt(x, 10);
    y = parseInt(y, 10);
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
      return false;
    }
    return this._bits[x][y];
  };

  /*
   * Flip the bits in this map.
  */


  Mask.prototype.invert = function() {
    return this._bits = this._bits.map(function(row) {
      return row.map(function(b) {
        return !b;
      });
    });
  };

  /*
   * @returns {Array} the dimensions of the map
  */


  Mask.prototype.getSize = function() {
    return [this.width, this.height];
  };

  objects.accessors(Mask.prototype, {
    /*
       * Rect of this Mask.
    */

    rect: {
      get: function() {
        return new gamejs.Rect([0, 0], [this.width, this.height]);
      }
    },
    /*
       * @returns {Number} number of set pixels in this mask.
    */

    length: {
      get: function() {
        var c;
        c = 0;
        this._bits.forEach(function(row) {
          return row.forEach(function(b) {
            if (b) {
              return c++;
            }
          });
        });
        return c;
      }
    }
  });

}).call(this);
