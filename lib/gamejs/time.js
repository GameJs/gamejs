// Generated by CoffeeScript 1.4.0

/*
 * @fileoverview
 * Provides tools for game time managment.
 *
 * This is very different from how PyGame works. We can not
 * pause the execution of the script in Browser JavaScript, so what
 * we do you do is write a main function which contains the code
 * you would put into your main loop and pass that to `fpsCallback()`:
 *
 * @example
 *     function main() {
 *         // update models
 *         // draw to screen
 *      }
 *      gamejs.time.fpsCallback(main, this, 30)
 *      
 *      function aiUpdate() {
 *         // do stuff that needs low update rates
 *      }
 *      gamejs.time.fpsCallback(aiUpdate, this, 10)
 *
 *
*/


(function() {
  var CALLBACKS, CALLBACKS_LASTCALL, STARTTIME, TIMER, TIMER_LASTCALL, perInterval;

  TIMER_LASTCALL = null;

  CALLBACKS = {};

  CALLBACKS_LASTCALL = {};

  TIMER = null;

  STARTTIME = null;

  /* @ignore
  */


  exports.init = function() {
    STARTTIME = Date.now();
    TIMER = setInterval(perInterval, 10);
  };

  /*
   * @param {Function} fn the function to call back
   * @param {Object} thisObj `this` will be set to that object when executing the function
   * @param {Number} fps specify the framerate by which you want the callback to be called. (e.g. 30 = 30 times per seconds). default: 30
  */


  exports.fpsCallback = function(fn, thisObj, fps) {
    if (fps === void 0) {
      fps = 30;
    }
    fps = parseInt(1000 / fps, 10);
    CALLBACKS[fps] = CALLBACKS[fps] || [];
    CALLBACKS_LASTCALL[fps] = CALLBACKS_LASTCALL[fps] || 0;
    CALLBACKS[fps].push({
      'rawFn': fn,
      'callback': function(msWaited) {
        return fn.apply(thisObj, [msWaited]);
      }
    });
  };

  /*
   * @param {Function} callback the function delete
   * @param {Number} fps
  */


  exports.deleteCallback = function(callback, fps) {
    var callbacks, result;
    result = null;
    fps = parseInt(1000 / fps, 10);
    callbacks = CALLBACKS[fps];
    if (callbacks) {
      CALLBACKS[fps] = callbacks.filter(function(fnInfo, idx) {
        return result = fnInfo.rawFn !== callback;
      });
    }
    return result;
  };

  perInterval = function() {
    var callbackWrapper, fpsKey, lastCalls, msNow, msWaited;
    msNow = Date.now();
    lastCalls = CALLBACKS_LASTCALL;
    callbackWrapper = function(fnInfo) {
      return fnInfo.callback(msWaited);
    };
    for (fpsKey in lastCalls) {
      if (!lastCalls[fpsKey]) {
        CALLBACKS_LASTCALL[fpsKey] = msNow;
      }
      msWaited = msNow - lastCalls[fpsKey];
      if (fpsKey <= msWaited) {
        CALLBACKS_LASTCALL[fpsKey] = msNow;
        CALLBACKS[fpsKey].forEach(callbackWrapper, this);
      }
    }
  };

}).call(this);
