// Generated by CoffeeScript 1.4.0
(function() {
  var SurfaceArray, accessors, gamejs;

  gamejs = require('../gamejs');

  accessors = require('./utils/objects').accessors;

  /*
   * @fileoverview Fast pixel access.
   *
   * @example
   *
   *   // create array from display surface
   *   srfArray = new SurfaceArray(display)
   *   // direct pixel access
   *   srfArray.set(50, 100, [255, 0, 0, 100])
   *   console.log(srfArray.get(30, 50))
   *   // blit modified array back to display surface
   *   blitArray(display, srfArray)
  */


  /*
   * Directly copy values from an array into a Surface.
   *
   * This is faster than blitting the `surface` property on a SurfaceArray
   *
   * The array must be the same dimensions as the Surface and will completely
   * replace all pixel values.
   * @param {gamejs.Surface} surface
   * @param {gamejs.surfacearray.SurfaceArray} surfaceArray
  */


  exports.blitArray = function(surface, surfaceArray) {
    surface.context.putImageData(surfaceArray.imageData, 0, 0);
  };

  /*
   * The SurfaceArray can be constructed with a surface whose values
   * are then used to initialize the pixel array.
   *
   * The surface passed as argument is not modified by the SurfaceArray.
   *
   * If an array is used to construct SurfaceArray, the array must describe
   * the dimensions of the SurfaceArray [width, height].
   *
   * @param {gamejs.Surface|Array} surfaceOrDimensions
   * @see http://dev.w3.org/html5/2dcontext/#pixel-manipulation
  */


  SurfaceArray = exports.SurfaceArray = function(surfaceOrDimensions) {
    var data, imageData, size;
    size = null;
    data = null;
    imageData = null;
    /*
       * Set rgba value at position x, y.
       *
       * For performance reasons this function has only one signature
       * being Number, Number, Array[4].
       *
       * @param {Number} x x position of pixel
       * @param {Number} y y position of pixel
       * @param {Array} rgba [red, green, blue, alpha] values [255, 255, 255, 255] (alpha, the last argument defaults to 255)
       * @throws Error if x, y out of range
    */

    this.set = function(x, y, rgba) {
      var offset;
      offset = (x * 4) + (y * size[0] * 4);
      /* faster without
      if (offset + 3 >= data.length || x < 0 || y < 0) {
         throw new Error('x, y out of range', x, y)
      }
      *
      */

      data[offset] = rgba[0];
      data[offset + 1] = rgba[1];
      data[offset + 2] = rgba[2];
      data[offset + 3] = rgba[3] === void 0 ? 255 : rgba[3];
    };
    /*
       * Get rgba value at position xy,
       * @param {Number} x
       * @param {Number} y
       * @returns {Array} [red, green, blue, alpha]
    */

    this.get = function(x, y) {
      var offset;
      offset = (x * 4) + (y * size[0] * 4);
      return [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];
    };
    /*
       * a new gamejs.Surface on every access, representing
       * the current state of the SurfaceArray.
       * @type {gamejs.Surface}
    */

    this.surface = null;
    accessors(this, {
      surface: {
        get: function() {
          var s;
          s = new gamejs.Surface(size);
          s.context.putImageData(imageData, 0, 0);
          return s;
        }
      },
      imageData: {
        get: function() {
          return imageData;
        }
      }
    });
    this.getSize = function() {
      return size;
    };
    /*
       * constructor
    */

    if (surfaceOrDimensions instanceof Array) {
      size = surfaceOrDimensions;
      imageData = gamejs.display.getSurface().context.createImageData(size[0], size[1]);
      data = imageData.data;
    } else {
      size = surfaceOrDimensions.getSize();
      imageData = surfaceOrDimensions.getImageData(0, 0, size[0], size[1]);
      data = imageData.data;
    }
    return this;
  };

}).call(this);
